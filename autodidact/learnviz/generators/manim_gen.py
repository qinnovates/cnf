"""
Manim Code Generator

Generates Manim Python code from visualization plans.
Includes templates for common educational patterns.
"""

import json
from typing import Dict, Any, List, Optional
from pathlib import Path


class ManimTemplate:
    """Base class for Manim templates."""

    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description

    def generate(self, params: Dict[str, Any]) -> str:
        raise NotImplementedError


class BinarySearchTemplate(ManimTemplate):
    """Template for binary search visualization."""

    def __init__(self):
        super().__init__(
            "binary_search",
            "Visualize binary search algorithm step by step"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        array = params.get("array", [1, 3, 5, 7, 9, 11, 13, 15, 17, 19])
        target = params.get("target", 7)

        return f'''"""
Binary Search Visualization
Generated by LearnViz
"""
from manim import *

class BinarySearchScene(Scene):
    def construct(self):
        # Configuration
        array = {array}
        target = {target}

        # Title
        title = Text("Binary Search Algorithm", font_size=48)
        subtitle = Text(f"Finding {{target}} in a sorted array", font_size=24)
        subtitle.next_to(title, DOWN)

        self.play(Write(title))
        self.play(FadeIn(subtitle))
        self.wait(1)
        self.play(FadeOut(title), FadeOut(subtitle))

        # Create array visualization
        boxes = VGroup()
        numbers = VGroup()
        indices = VGroup()

        for i, val in enumerate(array):
            box = Square(side_length=0.8)
            box.set_stroke(WHITE, 2)
            num = Text(str(val), font_size=24)
            idx = Text(str(i), font_size=16, color=GRAY)

            if i > 0:
                box.next_to(boxes[-1], RIGHT, buff=0.1)

            num.move_to(box.get_center())
            idx.next_to(box, DOWN, buff=0.1)

            boxes.add(box)
            numbers.add(num)
            indices.add(idx)

        array_group = VGroup(boxes, numbers, indices)
        array_group.center()

        # Target display
        target_text = Text(f"Target: {{target}}", font_size=32)
        target_text.to_edge(UP)

        self.play(
            Create(boxes),
            Write(numbers),
            Write(indices),
            Write(target_text)
        )
        self.wait(1)

        # Binary search animation
        left, right = 0, len(array) - 1
        step = 1

        # Pointers
        left_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)
        right_arrow = Arrow(start=DOWN, end=UP, color=RED).scale(0.5)
        left_label = Text("L", font_size=20, color=BLUE)
        right_label = Text("R", font_size=20, color=RED)

        left_arrow.next_to(boxes[left], DOWN, buff=0.5)
        right_arrow.next_to(boxes[right], DOWN, buff=0.5)
        left_label.next_to(left_arrow, DOWN, buff=0.1)
        right_label.next_to(right_arrow, DOWN, buff=0.1)

        self.play(
            Create(left_arrow), Write(left_label),
            Create(right_arrow), Write(right_label)
        )

        while left <= right:
            mid = (left + right) // 2

            # Step indicator
            step_text = Text(f"Step {{step}}: Check middle (index {{mid}})", font_size=24)
            step_text.to_edge(DOWN)
            self.play(Write(step_text))

            # Highlight middle
            self.play(boxes[mid].animate.set_fill(YELLOW, opacity=0.5))
            self.wait(0.5)

            if array[mid] == target:
                # Found!
                found_text = Text(f"Found {{target}} at index {{mid}}!", font_size=32, color=GREEN)
                found_text.next_to(step_text, UP)
                self.play(
                    boxes[mid].animate.set_fill(GREEN, opacity=0.7),
                    Write(found_text)
                )
                break
            elif array[mid] < target:
                # Go right
                compare_text = Text(f"{{array[mid]}} < {{target}}, search right half", font_size=20)
                compare_text.next_to(step_text, UP)
                self.play(Write(compare_text))

                # Gray out left half
                for i in range(left, mid + 1):
                    self.play(
                        boxes[i].animate.set_fill(GRAY, opacity=0.3),
                        run_time=0.2
                    )

                left = mid + 1
                left_arrow.generate_target()
                left_arrow.target.next_to(boxes[left] if left < len(array) else boxes[-1], DOWN, buff=0.5)
                left_label.generate_target()
                left_label.target.next_to(left_arrow.target, DOWN, buff=0.1)
                self.play(
                    MoveToTarget(left_arrow),
                    MoveToTarget(left_label)
                )
                self.play(FadeOut(compare_text))
            else:
                # Go left
                compare_text = Text(f"{{array[mid]}} > {{target}}, search left half", font_size=20)
                compare_text.next_to(step_text, UP)
                self.play(Write(compare_text))

                # Gray out right half
                for i in range(mid, right + 1):
                    self.play(
                        boxes[i].animate.set_fill(GRAY, opacity=0.3),
                        run_time=0.2
                    )

                right = mid - 1
                right_arrow.generate_target()
                right_arrow.target.next_to(boxes[right] if right >= 0 else boxes[0], DOWN, buff=0.5)
                right_label.generate_target()
                right_label.target.next_to(right_arrow.target, DOWN, buff=0.1)
                self.play(
                    MoveToTarget(right_arrow),
                    MoveToTarget(right_label)
                )
                self.play(FadeOut(compare_text))

            self.play(boxes[mid].animate.set_fill(WHITE, opacity=0))
            self.play(FadeOut(step_text))
            step += 1

        self.wait(2)


if __name__ == "__main__":
    # Render with: manim -pql binary_search.py BinarySearchScene
    pass
'''


class SortingTemplate(ManimTemplate):
    """Template for sorting algorithm visualization."""

    def __init__(self):
        super().__init__(
            "sorting",
            "Visualize sorting algorithms (bubble, selection, insertion)"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        array = params.get("array", [64, 34, 25, 12, 22, 11, 90])
        algorithm = params.get("algorithm", "bubble")

        return f'''"""
{algorithm.title()} Sort Visualization
Generated by LearnViz
"""
from manim import *

class SortingScene(Scene):
    def construct(self):
        array = {array}
        n = len(array)

        # Title
        title = Text("{algorithm.title()} Sort", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Create bars
        bars = self.create_bars(array)
        self.play(Create(bars))
        self.wait(1)

        # Sort with animation
        self.{algorithm}_sort(bars, array)

        # Done
        done_text = Text("Sorted!", font_size=36, color=GREEN)
        done_text.to_edge(DOWN)
        self.play(Write(done_text))
        self.play(bars.animate.set_color(GREEN))
        self.wait(2)

    def create_bars(self, array):
        bars = VGroup()
        max_val = max(array)
        bar_width = 0.8
        spacing = 0.9

        for i, val in enumerate(array):
            height = (val / max_val) * 4
            bar = Rectangle(
                width=bar_width,
                height=height,
                fill_opacity=0.7,
                fill_color=BLUE,
                stroke_color=WHITE
            )
            bar.move_to(
                LEFT * (len(array) / 2 - i) * spacing + DOWN * (2 - height / 2)
            )

            # Value label
            label = Text(str(val), font_size=16)
            label.next_to(bar, UP, buff=0.1)
            bar.label = label

            bars.add(VGroup(bar, label))

        return bars

    def swap_bars(self, bars, i, j):
        bar_i, bar_j = bars[i], bars[j]
        pos_i, pos_j = bar_i.get_center(), bar_j.get_center()

        self.play(
            bar_i.animate.set_color(RED),
            bar_j.animate.set_color(RED),
            run_time=0.3
        )
        self.play(
            bar_i.animate.move_to([pos_j[0], bar_i.get_center()[1], 0]),
            bar_j.animate.move_to([pos_i[0], bar_j.get_center()[1], 0]),
            run_time=0.5
        )
        self.play(
            bar_i.animate.set_color(BLUE),
            bar_j.animate.set_color(BLUE),
            run_time=0.3
        )

        # Swap in list
        bars[i], bars[j] = bars[j], bars[i]

    def bubble_sort(self, bars, array):
        n = len(array)
        for i in range(n):
            for j in range(0, n - i - 1):
                # Highlight comparison
                self.play(
                    bars[j].animate.set_color(YELLOW),
                    bars[j + 1].animate.set_color(YELLOW),
                    run_time=0.2
                )

                if array[j] > array[j + 1]:
                    self.swap_bars(bars, j, j + 1)
                    array[j], array[j + 1] = array[j + 1], array[j]
                else:
                    self.play(
                        bars[j].animate.set_color(BLUE),
                        bars[j + 1].animate.set_color(BLUE),
                        run_time=0.2
                    )

    def selection_sort(self, bars, array):
        n = len(array)
        for i in range(n):
            min_idx = i
            self.play(bars[i].animate.set_color(PURPLE), run_time=0.2)

            for j in range(i + 1, n):
                self.play(bars[j].animate.set_color(YELLOW), run_time=0.1)
                if array[j] < array[min_idx]:
                    if min_idx != i:
                        self.play(bars[min_idx].animate.set_color(BLUE), run_time=0.1)
                    min_idx = j
                    self.play(bars[min_idx].animate.set_color(RED), run_time=0.1)
                else:
                    self.play(bars[j].animate.set_color(BLUE), run_time=0.1)

            if min_idx != i:
                self.swap_bars(bars, i, min_idx)
                array[i], array[min_idx] = array[min_idx], array[i]

            self.play(bars[i].animate.set_color(GREEN), run_time=0.2)

    def insertion_sort(self, bars, array):
        for i in range(1, len(array)):
            key = array[i]
            self.play(bars[i].animate.set_color(YELLOW), run_time=0.2)

            j = i - 1
            while j >= 0 and array[j] > key:
                self.swap_bars(bars, j, j + 1)
                array[j + 1] = array[j]
                j -= 1

            array[j + 1] = key
            self.play(bars[j + 1].animate.set_color(BLUE), run_time=0.2)


if __name__ == "__main__":
    pass
'''


class PythagoreanTemplate(ManimTemplate):
    """Template for Pythagorean theorem proof."""

    def __init__(self):
        super().__init__(
            "pythagorean",
            "Visualize Pythagorean theorem proof"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        return '''"""
Pythagorean Theorem Visualization
Generated by LearnViz
"""
from manim import *

class PythagoreanScene(Scene):
    def construct(self):
        # Title
        title = Text("The Pythagorean Theorem", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Create right triangle
        a, b = 2, 1.5  # sides
        c = np.sqrt(a**2 + b**2)  # hypotenuse

        triangle = Polygon(
            ORIGIN,
            RIGHT * a,
            RIGHT * a + UP * b,
            fill_opacity=0.3,
            fill_color=BLUE,
            stroke_color=WHITE
        )
        triangle.move_to(ORIGIN)

        # Labels
        a_label = MathTex("a").next_to(triangle, DOWN)
        b_label = MathTex("b").next_to(triangle, RIGHT)
        c_label = MathTex("c").move_to(triangle.get_center() + UP * 0.5 + LEFT * 0.5)

        # Right angle marker
        right_angle = RightAngle(
            Line(ORIGIN, RIGHT * a),
            Line(RIGHT * a, RIGHT * a + UP * b),
            length=0.2
        )

        self.play(Create(triangle))
        self.play(Write(a_label), Write(b_label), Write(c_label))
        self.play(Create(right_angle))
        self.wait(1)

        # Create squares on each side
        sq_a = Square(side_length=a, fill_opacity=0.5, fill_color=RED)
        sq_a.next_to(triangle, DOWN, buff=0)

        sq_b = Square(side_length=b, fill_opacity=0.5, fill_color=GREEN)
        sq_b.next_to(triangle, RIGHT, buff=0)

        sq_c = Square(side_length=c, fill_opacity=0.5, fill_color=YELLOW)
        # Position c square on hypotenuse (simplified positioning)
        sq_c.rotate(np.arctan(b/a))
        sq_c.move_to(triangle.get_center() + UP * 1.5 + LEFT * 1)

        # Area labels
        a2_label = MathTex("a^2", color=RED).move_to(sq_a.get_center())
        b2_label = MathTex("b^2", color=GREEN).move_to(sq_b.get_center())
        c2_label = MathTex("c^2", color=YELLOW).move_to(sq_c.get_center())

        self.play(
            Create(sq_a), Write(a2_label),
            Create(sq_b), Write(b2_label),
            run_time=2
        )
        self.wait(1)

        self.play(Create(sq_c), Write(c2_label), run_time=2)
        self.wait(1)

        # Show the equation
        equation = MathTex("a^2", "+", "b^2", "=", "c^2", font_size=56)
        equation.to_edge(DOWN)
        equation[0].set_color(RED)
        equation[2].set_color(GREEN)
        equation[4].set_color(YELLOW)

        self.play(Write(equation))
        self.wait(1)

        # Highlight equation
        box = SurroundingRectangle(equation, color=WHITE, buff=0.2)
        self.play(Create(box))
        self.wait(2)


if __name__ == "__main__":
    pass
'''


class TreeTraversalTemplate(ManimTemplate):
    """Template for binary tree traversal visualization."""

    def __init__(self):
        super().__init__(
            "tree_traversal",
            "Visualize tree traversal (inorder, preorder, postorder)"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        traversal = params.get("traversal", "inorder")
        tree = params.get("tree", [1, 2, 3, 4, 5, 6, 7])

        return f'''"""
Binary Tree {traversal.title()} Traversal
Generated by LearnViz
"""
from manim import *

class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeTraversalScene(Scene):
    def construct(self):
        # Title
        title = Text("{traversal.title()} Traversal", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Build tree from array
        tree_vals = {tree}
        root = self.build_tree(tree_vals)

        # Draw tree
        nodes, edges = self.draw_tree(root)
        self.play(*[Create(e) for e in edges])
        self.play(*[Create(n) for n in nodes.values()])
        self.wait(1)

        # Traversal order display
        order_label = Text("Visit Order: ", font_size=24)
        order_label.to_edge(DOWN).shift(LEFT * 4)
        order_values = VGroup()
        self.play(Write(order_label))

        # Perform traversal
        visited = []
        self.{traversal}_traverse(root, nodes, visited, order_values, order_label)

        self.wait(2)

    def build_tree(self, arr):
        if not arr:
            return None
        nodes = [TreeNode(v) if v is not None else None for v in arr]
        for i, node in enumerate(nodes):
            if node:
                left_idx = 2 * i + 1
                right_idx = 2 * i + 2
                if left_idx < len(nodes):
                    node.left = nodes[left_idx]
                if right_idx < len(nodes):
                    node.right = nodes[right_idx]
        return nodes[0] if nodes else None

    def draw_tree(self, root, x=0, y=2, dx=2, dy=1.5, nodes=None, edges=None, depth=0):
        if nodes is None:
            nodes = {{}}
            edges = []

        if root is None:
            return nodes, edges

        # Create node circle
        circle = Circle(radius=0.4, fill_opacity=0.7, fill_color=BLUE, stroke_color=WHITE)
        label = Text(str(root.val), font_size=24)
        node_group = VGroup(circle, label)
        node_group.move_to([x, y, 0])

        nodes[root.val] = node_group

        # Draw children
        if root.left:
            child_x = x - dx / (depth + 1)
            child_y = y - dy
            edge = Line([x, y - 0.4, 0], [child_x, child_y + 0.4, 0], color=WHITE)
            edges.append(edge)
            self.draw_tree(root.left, child_x, child_y, dx, dy, nodes, edges, depth + 1)

        if root.right:
            child_x = x + dx / (depth + 1)
            child_y = y - dy
            edge = Line([x, y - 0.4, 0], [child_x, child_y + 0.4, 0], color=WHITE)
            edges.append(edge)
            self.draw_tree(root.right, child_x, child_y, dx, dy, nodes, edges, depth + 1)

        return nodes, edges

    def visit_node(self, node, nodes, visited, order_values, order_label):
        if node.val in nodes:
            # Highlight visited
            self.play(nodes[node.val][0].animate.set_fill(GREEN, opacity=0.8), run_time=0.5)

            # Add to order
            val_text = Text(str(node.val), font_size=24, color=GREEN)
            if not visited:
                val_text.next_to(order_label, RIGHT)
            else:
                val_text.next_to(order_values[-1], RIGHT, buff=0.3)
            order_values.add(val_text)
            visited.append(node.val)
            self.play(Write(val_text), run_time=0.3)

    def inorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.inorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.visit_node(node, nodes, visited, order_values, order_label)
        self.inorder_traverse(node.right, nodes, visited, order_values, order_label)

    def preorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.visit_node(node, nodes, visited, order_values, order_label)
        self.preorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.preorder_traverse(node.right, nodes, visited, order_values, order_label)

    def postorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.postorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.postorder_traverse(node.right, nodes, visited, order_values, order_label)
        self.visit_node(node, nodes, visited, order_values, order_label)


if __name__ == "__main__":
    pass
'''


# Registry of all templates
TEMPLATES = {
    "binary_search": BinarySearchTemplate(),
    "search_visual": BinarySearchTemplate(),  # alias
    "sorting": SortingTemplate(),
    "sort_visual": SortingTemplate(),  # alias
    "bubble_sort": SortingTemplate(),
    "pythagorean": PythagoreanTemplate(),
    "proof_steps": PythagoreanTemplate(),  # alias
    "tree_traversal": TreeTraversalTemplate(),
}


def generate_manim_code(
    plan: Dict[str, Any],
    template_name: Optional[str] = None,
    params: Optional[Dict[str, Any]] = None
) -> str:
    """
    Generate Manim code from a visualization plan.

    Args:
        plan: Visualization plan from analyzer
        template_name: Override template selection
        params: Parameters for template

    Returns:
        Generated Manim Python code
    """
    # Determine template
    template_key = template_name or plan.get("template")

    if template_key and template_key in TEMPLATES:
        template = TEMPLATES[template_key]
        return template.generate(params or {})

    # Fallback: generate generic scene from plan
    return generate_generic_scene(plan)


def generate_generic_scene(plan: Dict[str, Any]) -> str:
    """
    Generate a generic Manim scene when no template matches.
    """
    title = plan.get("title", "Visualization")
    scenes = plan.get("scenes", [])

    scene_methods = []
    for scene in scenes:
        method = f'''
    def scene_{scene["id"]}_{scene["name"]}(self):
        """
        {scene["description"]}
        Duration: {scene["duration"]}s
        """
        # TODO: Implement {scene["name"]}
        text = Text("{scene["description"][:40]}...", font_size=24)
        self.play(Write(text))
        self.wait({scene["duration"]})
        self.play(FadeOut(text))
'''
        scene_methods.append(method)

    scene_calls = "\n        ".join(
        [f"self.scene_{s['id']}_{s['name']}()" for s in scenes]
    )

    return f'''"""
{title}
Generated by LearnViz

This is a template - fill in the scene implementations.
"""
from manim import *

class GeneratedScene(Scene):
    def construct(self):
        # Run all scenes
        {scene_calls}

{"".join(scene_methods)}

if __name__ == "__main__":
    # Render with: manim -pql generated_scene.py GeneratedScene
    pass
'''


# CLI interface
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Available templates:")
        for name, template in TEMPLATES.items():
            print(f"  {name}: {template.description}")
        print("\nUsage: python manim_gen.py <template_name> [params_json]")
        sys.exit(1)

    template_name = sys.argv[1]
    params = json.loads(sys.argv[2]) if len(sys.argv) > 2 else {}

    if template_name not in TEMPLATES:
        print(f"Unknown template: {template_name}")
        sys.exit(1)

    code = TEMPLATES[template_name].generate(params)
    print(code)
